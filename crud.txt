crud files

app.crud.users.py
from typing import List, Optional, Union
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.models import User
from app.schemas.user import UserCreate, UserRead


# =============================
# CREATE USER
# =============================
async def create_user(db: AsyncSession, user_in: Union[UserCreate, dict]) -> UserRead:
    """
    Create a new user.
    """
    if isinstance(user_in, dict):
        user_in = UserCreate(**user_in)

    user = User(**user_in.model_dump())
    db.add(user)
    await db.commit()
    await db.refresh(user)
    return UserRead.model_validate(user)


# =============================
# GET USER BY ID
# =============================
async def get_user(db: AsyncSession, user_id: str) -> Optional[UserRead]:
    """
    Retrieve a single user by ID.
    Only active users are returned.
    """
    user = await db.get(User, user_id)
    if user and user.is_active:
        return UserRead.model_validate(user)
    return None


# =============================
# GET USER BY EMAIL
# =============================
async def get_user_by_email(db: AsyncSession, email: str) -> Optional[UserRead]:
    """
    Retrieve a single user by email.
    Only active users are returned.
    """
    result = await db.execute(select(User).where(User.email == email, User.is_active == True))
    user = result.scalars().first()
    if user:
        return UserRead.model_validate(user)
    return None


# =============================
# LIST USERS
# =============================
async def list_users(
    db: AsyncSession, *, limit: int = 100, offset: int = 0, include_inactive: bool = False
) -> List[UserRead]:
    """
    List users with pagination.
    Set include_inactive=True to also return inactive users.
    """
    query = select(User)
    if not include_inactive:
        query = query.where(User.is_active == True)
    query = query.limit(limit).offset(offset)

    result = await db.execute(query)
    users = result.scalars().all()
    return [UserRead.model_validate(u) for u in users]


# =============================
# UPDATE USER
# =============================
async def update_user(db: AsyncSession, user_id: str, update_data: dict) -> Optional[UserRead]:
    """
    Update a user by ID. Ignores immutable fields.
    """
    user = await db.get(User, user_id)
    if not user or not user.is_active:
        return None

    for key, value in update_data.items():
        if key in ("id", "created_at", "email"):
            continue
        if hasattr(user, key):
            setattr(user, key, value)

    db.add(user)
    await db.commit()
    await db.refresh(user)
    return UserRead.model_validate(user)


# =============================
# SOFT DELETE USER
# =============================
async def delete_user(db: AsyncSession, user_id: str) -> bool:
    """
    Soft-delete a user by marking is_active=False.
    Returns True if user existed and was deactivated, False if not found.
    """
    user = await db.get(User, user_id)
    if not user or not user.is_active:
        return False

    user.is_active = False
    db.add(user)
    await db.commit()
    await db.refresh(user)
    return True

app.crud.vendors.py
from typing import List, Optional, Union
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.models import Vendor
from app.schemas.vendor import VendorCreate, VendorRead


# =============================
# CREATE VENDOR
# =============================
async def create_vendor(db: AsyncSession, vendor_in: Union[VendorCreate, dict]) -> VendorRead:
    """
    Create a new vendor.
    Accepts either a VendorCreate Pydantic model or a dict.
    """
    if isinstance(vendor_in, dict):
        vendor_in = VendorCreate(**vendor_in)

    vendor_obj = Vendor(**vendor_in.model_dump())
    db.add(vendor_obj)
    await db.commit()
    await db.refresh(vendor_obj)
    return VendorRead.model_validate(vendor_obj)


# =============================
# GET VENDOR BY ID
# =============================
async def get_vendor(db: AsyncSession, vendor_id: str) -> Optional[VendorRead]:
    """
    Fetch a vendor by ID.
    Only active vendors are returned.
    """
    vendor_obj = await db.get(Vendor, vendor_id)
    if vendor_obj and (not hasattr(vendor_obj, "is_active") or vendor_obj.is_active):
        return VendorRead.model_validate(vendor_obj)
    return None


# =============================
# LIST VENDORS
# =============================
async def list_vendors(
    db: AsyncSession, *, limit: int = 100, offset: int = 0, include_inactive: bool = False
) -> List[VendorRead]:
    """
    List vendors with pagination.
    Set include_inactive=True to include soft-deleted vendors.
    """
    query = select(Vendor)
    if not include_inactive and hasattr(Vendor, "is_active"):
        query = query.where(Vendor.is_active == True)
    query = query.limit(limit).offset(offset)

    result = await db.execute(query)
    vendors = result.scalars().all()
    return [VendorRead.model_validate(v) for v in vendors]


# =============================
# UPDATE VENDOR
# =============================
async def update_vendor(db: AsyncSession, vendor_id: str, update_data: dict) -> Optional[VendorRead]:
    """
    Update an existing vendor by ID.
    Immutable fields are ignored.
    """
    vendor_obj = await db.get(Vendor, vendor_id)
    if not vendor_obj or (hasattr(vendor_obj, "is_active") and not vendor_obj.is_active):
        return None

    immutable_fields = {"id", "created_at"}
    for key, value in update_data.items():
        if key in immutable_fields:
            continue
        if hasattr(vendor_obj, key):
            setattr(vendor_obj, key, value)

    db.add(vendor_obj)
    await db.commit()
    await db.refresh(vendor_obj)
    return VendorRead.model_validate(vendor_obj)


# =============================
# DELETE VENDOR (SOFT DELETE)
# =============================
async def delete_vendor(db: AsyncSession, vendor_id: str) -> bool:
    """
    Soft-delete a vendor by marking is_active=False.
    Falls back to hard-delete if no is_active field exists.
    Returns True if vendor existed, False otherwise.
    """
    vendor_obj = await db.get(Vendor, vendor_id)
    if not vendor_obj:
        return False

    if hasattr(vendor_obj, "is_active"):
        vendor_obj.is_active = False
        db.add(vendor_obj)
        await db.commit()
        await db.refresh(vendor_obj)
        return True

    await db.delete(vendor_obj)
    await db.commit()
    return True

app.crud.buyers.py
from typing import List, Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.models import Buyer
from app.schemas.buyer import BuyerCreate, BuyerRead


async def create_buyer(db: AsyncSession, buyer_in: BuyerCreate, user_id: Optional[str] = None) -> BuyerRead:
    """
    Create a new buyer.
    Optionally associate it with a user_id.
    """
    buyer_data = buyer_in.model_dump()
    if user_id:
        buyer_data["user_id"] = user_id
    buyer = Buyer(**buyer_data)
    db.add(buyer)
    await db.commit()
    await db.refresh(buyer)
    return BuyerRead.model_validate(buyer)


async def get_buyer(db: AsyncSession, buyer_id: str) -> Optional[Buyer]:
    """Fetch a buyer ORM object by ID."""
    result = await db.execute(select(Buyer).where(Buyer.id == buyer_id))
    buyer = result.scalars().first()
    return buyer


async def list_buyers(db: AsyncSession, *, limit: int = 100, offset: int = 0) -> List[BuyerRead]:
    """List buyers with pagination."""
    result = await db.execute(select(Buyer).limit(limit).offset(offset))
    buyers = result.scalars().all()
    return [BuyerRead.model_validate(b) for b in buyers]


async def update_buyer(db: AsyncSession, buyer_id: str, update_data: dict) -> Optional[BuyerRead]:
    """Update an existing buyer by ID."""
    buyer = await get_buyer(db, buyer_id)
    if not buyer:
        return None

    for key, value in update_data.items():
        if key in ("id", "created_at"):
            continue
        if hasattr(buyer, key):
            setattr(buyer, key, value)

    db.add(buyer)
    await db.commit()
    await db.refresh(buyer)
    return BuyerRead.model_validate(buyer)


async def delete_buyer(db: AsyncSession, buyer_id: str) -> bool:
    """Delete a buyer by ID."""
    buyer = await get_buyer(db, buyer_id)
    if not buyer:
        return False
    await db.delete(buyer)
    await db.commit()
    return True

app.crud.datasets.py
from typing import List, Optional, Union, Dict, Any
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.models.models import Dataset
from app.schemas.dataset import DatasetCreate, DatasetRead
from app.utils.embedding_utils import build_and_embed


async def create_dataset(db: AsyncSession, dataset_in: Union[DatasetCreate, dict]) -> DatasetRead:
    if isinstance(dataset_in, dict):
        dataset_in = DatasetCreate(**dataset_in)

    ds_dict: Dict[str, Any] = dataset_in.model_dump()

    if not ds_dict.get("embedding") or not ds_dict.get("embedding_input"):
        embedding_vector = await build_and_embed(ds_dict)
        ds_dict["embedding"] = embedding_vector
        ds_dict["embedding_input"] = ds_dict.get("embedding_input") or ""

    dataset_obj = Dataset(**ds_dict)
    db.add(dataset_obj)
    await db.commit()
    await db.refresh(dataset_obj)
    return DatasetRead.model_validate(dataset_obj)


async def get_dataset(db: AsyncSession, dataset_id: str) -> Optional[DatasetRead]:
    dataset_obj = await db.get(Dataset, dataset_id)
    return DatasetRead.model_validate(dataset_obj) if dataset_obj else None


async def list_datasets(db: AsyncSession, *, limit: int = 100, offset: int = 0) -> List[DatasetRead]:
    result = await db.execute(select(Dataset).limit(limit).offset(offset))
    datasets = result.scalars().all()
    return [DatasetRead.model_validate(ds) for ds in datasets]


async def update_dataset(db: AsyncSession, dataset_id: str, update_data: dict) -> Optional[DatasetRead]:
    dataset_obj = await db.get(Dataset, dataset_id)
    if not dataset_obj:
        return None

    embedding_fields = {"title", "description", "domain", "topics", "columns"}
    rebuild_embedding = any(field in update_data for field in embedding_fields)

    for key, value in update_data.items():
        if key in ("id", "created_at"):
            continue
        if hasattr(dataset_obj, key):
            setattr(dataset_obj, key, value)

    if rebuild_embedding:
        embedding_vector = await build_and_embed(dataset_obj.__dict__)
        dataset_obj.embedding = embedding_vector
        dataset_obj.embedding_input = dataset_obj.embedding_input or ""

    db.add(dataset_obj)
    await db.commit()
    await db.refresh(dataset_obj)
    return DatasetRead.model_validate(dataset_obj)


async def delete_dataset(db: AsyncSession, dataset_id: str) -> bool:
    dataset_obj = await db.get(Dataset, dataset_id)
    if not dataset_obj:
        return False

    if hasattr(dataset_obj, "status"):
        dataset_obj.status = "inactive"
        db.add(dataset_obj)
        await db.commit()
        await db.refresh(dataset_obj)
        return True

    await db.delete(dataset_obj)
    await db.commit()
    return True

app.crud.dataset_columns.py
from typing import List, Optional, Union
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.models.models import DatasetColumn
from app.schemas.dataset_column import DatasetColumnCreate, DatasetColumnRead


# =============================
# CREATE DATASET COLUMN
# =============================
async def create_dataset_column(
    db: AsyncSession, col_in: Union[DatasetColumnCreate, dict]
) -> DatasetColumnRead:
    if isinstance(col_in, dict):
        col_in = DatasetColumnCreate(**col_in)

    col = DatasetColumn(**col_in.model_dump())
    db.add(col)
    await db.commit()
    await db.refresh(col)
    return DatasetColumnRead.model_validate(col)


# =============================
# GET DATASET COLUMN (ORM)
# =============================
async def get_dataset_column_obj(db: AsyncSession, col_id: int) -> Optional[DatasetColumn]:
    return await db.get(DatasetColumn, col_id)


# =============================
# LIST DATASET COLUMNS
# =============================
async def list_dataset_columns(db: AsyncSession, dataset_id: str) -> List[DatasetColumnRead]:
    result = await db.execute(select(DatasetColumn).where(DatasetColumn.dataset_id == dataset_id))
    cols = result.scalars().all()
    return [DatasetColumnRead.model_validate(col) for col in cols]


# =============================
# UPDATE DATASET COLUMN
# =============================
async def update_dataset_column(
    db: AsyncSession, col_id: int, update_data: dict
) -> Optional[DatasetColumnRead]:
    col = await db.get(DatasetColumn, col_id)
    if not col:
        return None

    for key, value in update_data.items():
        if key in ("id", "created_at"):
            continue
        if hasattr(col, key):
            setattr(col, key, value)

    db.add(col)
    await db.commit()
    await db.refresh(col)
    return DatasetColumnRead.model_validate(col)


# =============================
# DELETE DATASET COLUMN
# =============================
async def delete_dataset_column(db: AsyncSession, col_id: int) -> bool:
    col = await db.get(DatasetColumn, col_id)
    if not col:
        return False
    await db.delete(col)
    await db.commit()
    return True

app.crud.agents.py
from typing import List, Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.models import AIAgent
from app.schemas.agent import AgentCreate, AgentRead


async def create_agent(db: AsyncSession, agent_in: AgentCreate) -> AgentRead:
    """Create a new AI agent."""
    agent = AIAgent(**agent_in.model_dump())
    db.add(agent)
    await db.commit()
    await db.refresh(agent)
    return AgentRead.model_validate(agent)


async def get_agent(db: AsyncSession, agent_id: str) -> Optional[AIAgent]:
    """Fetch an AI agent ORM object by ID."""
    result = await db.execute(select(AIAgent).where(AIAgent.id == agent_id))
    agent = result.scalars().first()
    return agent


async def list_agents(
    db: AsyncSession,
    *,
    vendor_id: Optional[str] = None,
    active: Optional[bool] = None,
    limit: int = 100,
    offset: int = 0,
) -> List[AgentRead]:
    """List AI agents with optional filters."""
    q = select(AIAgent)
    if vendor_id:
        q = q.where(AIAgent.vendor_id == vendor_id)
    if active is not None:
        q = q.where(AIAgent.active == active)
    q = q.limit(limit).offset(offset)
    result = await db.execute(q)
    agents = result.scalars().all()
    return [AgentRead.model_validate(a) for a in agents]


async def update_agent(db: AsyncSession, agent_id: str, update_data: dict) -> Optional[AgentRead]:
    """Update an AI agent by ID."""
    agent = await get_agent(db, agent_id)
    if not agent:
        return None

    # Update attributes safely
    for key, value in update_data.items():
        if key in ("id", "created_at"):
            continue
        if hasattr(agent, key):
            setattr(agent, key, value)

    db.add(agent)
    await db.commit()
    await db.refresh(agent)
    return AgentRead.model_validate(agent)


async def delete_agent(db: AsyncSession, agent_id: str) -> bool:
    """Delete an AI agent by ID."""
    agent = await get_agent(db, agent_id)
    if not agent:
        return False
    await db.delete(agent)
    await db.commit()
    return True

app.crud.chats.py
from typing import List, Optional, Union
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.models import Chat
from app.schemas.chat import ChatCreate, ChatRead


# =============================
# CREATE CHAT
# =============================
async def create_chat(db: AsyncSession, chat_in: Union[ChatCreate, dict]) -> ChatRead:
    if isinstance(chat_in, dict):
        chat_in = ChatCreate(**chat_in)

    chat = Chat(**chat_in.model_dump())
    db.add(chat)
    await db.commit()
    await db.refresh(chat)
    return ChatRead.model_validate(chat)


# =============================
# GET CHAT (ORM object)
# =============================
async def get_chat_obj(db: AsyncSession, chat_id: str) -> Optional[Chat]:
    """Return ORM object for a chat, regardless of active status."""
    return await db.get(Chat, chat_id)


# =============================
# LIST CHATS
# =============================
async def list_chats(
    db: AsyncSession,
    user_id: Optional[str] = None,
    vendor_id: Optional[str] = None,
    agent_id: Optional[str] = None,
    chat_type: Optional[str] = None,
    limit: int = 100,
    offset: int = 0,
    include_inactive: bool = False,
) -> List[ChatRead]:
    query = select(Chat)
    if not include_inactive:
        query = query.where(Chat.is_active == True)
    if user_id:
        query = query.where(Chat.user_id == user_id)
    if vendor_id:
        query = query.where(Chat.vendor_id == vendor_id)
    if agent_id:
        query = query.where(Chat.agent_id == agent_id)
    if chat_type:
        query = query.where(Chat.chat_type == chat_type)

    query = query.limit(limit).offset(offset)
    result = await db.execute(query)
    chats = result.scalars().all()
    return [ChatRead.model_validate(c) for c in chats]


# =============================
# UPDATE CHAT
# =============================
async def update_chat(db: AsyncSession, chat_id: str, update_data: dict) -> Optional[ChatRead]:
    chat = await db.get(Chat, chat_id)
    if not chat or not chat.is_active:
        return None

    for key, value in update_data.items():
        if key in ("id", "created_at"):
            continue
        if hasattr(chat, key):
            setattr(chat, key, value)

    db.add(chat)
    await db.commit()
    await db.refresh(chat)
    return ChatRead.model_validate(chat)


# =============================
# SOFT DELETE CHAT
# =============================
async def delete_chat(db: AsyncSession, chat_id: str) -> bool:
    chat = await db.get(Chat, chat_id)
    if not chat or not chat.is_active:
        return False

    chat.is_active = False
    db.add(chat)
    await db.commit()
    await db.refresh(chat)
    return True

app.crud.chat_messages.py
from typing import List, Optional, Union
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.models.models import ChatMessage
from app.schemas.chat_message import ChatMessageCreate, ChatMessageRead


# =============================
# CREATE CHAT MESSAGE
# =============================
async def create_chat_message(
    db: AsyncSession, message_in: Union[ChatMessageCreate, dict]
) -> ChatMessageRead:
    if isinstance(message_in, dict):
        message_in = ChatMessageCreate(**message_in)

    message = ChatMessage(**message_in.model_dump())
    db.add(message)
    await db.commit()
    await db.refresh(message)
    return ChatMessageRead.model_validate(message)


# =============================
# GET MESSAGE (ORM object)
# =============================
async def get_chat_message_obj(db: AsyncSession, message_id: int) -> Optional[ChatMessage]:
    """Return ORM object, not Pydantic model."""
    return await db.get(ChatMessage, message_id)


# =============================
# LIST MESSAGES
# =============================
async def list_chat_messages(
    db: AsyncSession,
    chat_id: Optional[str] = None,
    sender_type: Optional[str] = None,
    limit: int = 100,
    offset: int = 0,
) -> List[ChatMessageRead]:
    query = select(ChatMessage)
    if chat_id:
        query = query.where(ChatMessage.chat_id == chat_id)
    if sender_type:
        query = query.where(ChatMessage.sender_type == sender_type)

    query = query.limit(limit).offset(offset)
    result = await db.execute(query)
    messages = result.scalars().all()
    return [ChatMessageRead.model_validate(m) for m in messages]


# =============================
# UPDATE MESSAGE
# =============================
async def update_chat_message(
    db: AsyncSession, message_id: int, update_data: dict
) -> Optional[ChatMessageRead]:
    message = await db.get(ChatMessage, message_id)
    if not message:
        return None

    for key in ("message", "message_metadata"):
        if key in update_data:
            setattr(message, key, update_data[key])

    db.add(message)
    await db.commit()
    await db.refresh(message)
    return ChatMessageRead.model_validate(message)


# =============================
# DELETE MESSAGE
# =============================
async def delete_chat_message(db: AsyncSession, message_id: int) -> bool:
    message = await db.get(ChatMessage, message_id)
    if not message:
        return False

    await db.delete(message)
    await db.commit()
    return True