app.api.vi.routes.*


auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi.security import OAuth2PasswordRequestForm

from app.core.db import get_session
from app.core import auth as auth_core
from app.schemas.user import UserRead
from app.models.models import User

router = APIRouter(prefix="/auth", tags=["authentication"])

# =========================================================
# REGISTER NEW USER
# =========================================================
@router.post("/register", response_model=UserRead, status_code=status.HTTP_201_CREATED)
async def register_user(
    email: str,
    password: str,
    role: str,
    full_name: str | None = None,
    db: AsyncSession = Depends(get_session),
):
    """
    Create a new user with hashed password.
    - email: user email (must be unique)
    - password: plaintext password
    - role: user role (buyer/vendor/admin)
    - full_name: optional full name
    """
    new_user = await auth_core.register_user(
        db=db, email=email, password=password, role=role, full_name=full_name
    )
    return new_user


# =========================================================
# LOGIN USER
# =========================================================
@router.post("/login")
async def login_user(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: AsyncSession = Depends(get_session),
):
    """
    Authenticate user and return JWT token.
    Expects form data with:
    - username (email)
    - password
    """
    user = await auth_core.authenticate_user(
        db, form_data.username, form_data.password
    )
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return auth_core.create_token_response(user)


# =========================================================
# GET CURRENT LOGGED-IN USER
# =========================================================
@router.get("/me", response_model=UserRead)
async def get_me(current_user: UserRead = Depends(auth_core.get_current_user)):
    """
    Returns the currently authenticated user's info.
    """
    return current_user

users.py
from fastapi import APIRouter, Depends, HTTPException, status, Query
from typing import List, Optional
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.db import get_session
from app.core.auth import get_current_user
from app.crud import users as crud_users
from app.schemas.user import UserRead
from app.models.models import User

router = APIRouter(prefix="/users", tags=["Users"])

# =========================================================
# ROLE-BASED ACCESS DECORATOR
# =========================================================
def require_roles(*allowed_roles: str):
    """
    Dependency generator to restrict access by user role.
    Example:
        current_user = Depends(require_roles("admin", "vendor"))
    """
    async def role_checker(current_user: UserRead = Depends(get_current_user)):
        if current_user.role not in allowed_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Insufficient permissions"
            )
        return current_user
    return role_checker


# =========================================================
# GET CURRENT USER PROFILE
# =========================================================
@router.get("/me", response_model=UserRead)
async def get_my_profile(current_user: UserRead = Depends(get_current_user)):
    """Return profile details of the currently authenticated user."""
    return current_user


# =========================================================
# LIST ALL USERS (Admin + Vendor + Buyer)
# =========================================================
@router.get("/", response_model=List[UserRead])
async def list_users(
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(require_roles("admin", "vendor", "buyer")),
    role: Optional[str] = Query(None, description="Filter users by role"),
    limit: int = Query(100, le=500, description="Maximum number of users to return"),
    offset: int = Query(0, ge=0, description="Number of users to skip for pagination"),
):
    """
    List all users (admin, vendor, buyer).  
    - Admin sees everyone  
    - Vendor or Buyer sees only active users  
    - Optional `role` query filter: ?role=vendor
    """
    include_inactive = current_user.role == "admin"
    all_users = await crud_users.list_users(
        db, limit=limit, offset=offset, include_inactive=include_inactive
    )

    if role:
        all_users = [u for u in all_users if u.role == role]

    # Optional: restrict sensitive fields for non-admins
    if current_user.role != "admin":
        for u in all_users:
            u.email = None  # Hide email for privacy

    return all_users


# =========================================================
# GET USER BY ID
# =========================================================
@router.get("/{user_id}", response_model=UserRead)
async def get_user_by_id(
    user_id: str,
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(require_roles("admin", "vendor", "buyer")),
):
    """
    Retrieve a single user by ID.
    - Admins can see all details
    - Vendors/Buyers see limited info
    """
    user = await crud_users.get_user(db, user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    # Non-admins cannot see sensitive fields
    if current_user.role != "admin":
        user.email = None

    return user


# =========================================================
# UPDATE OWN PROFILE (Self or Admin)
# =========================================================
@router.put("/{user_id}", response_model=UserRead)
async def update_user(
    user_id: str,
    update_data: dict,
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    """
    Update a user.
    - Admin can edit any user
    - Users can edit only themselves
    """
    if current_user.role != "admin" and current_user.id != user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only update your own profile",
        )

    updated_user = await crud_users.update_user(db, user_id, update_data)
    if not updated_user:
        raise HTTPException(status_code=404, detail="User not found or inactive")
    return updated_user


# =========================================================
# DELETE USER (Admin Only)
# =========================================================
@router.delete("/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_user(
    user_id: str,
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(require_roles("admin")),
):
    """
    Soft-delete a user (mark inactive).
    - Admin-only access.
    """
    success = await crud_users.delete_user(db, user_id)
    if not success:
        raise HTTPException(status_code=404, detail="User not found or already inactive")
    return {"detail": "User deleted successfully"}

vendors.py
from typing import List, Dict
from fastapi import (
    APIRouter, Depends, HTTPException, status, Query, Path, Body
)
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.db import get_session
from app.core.auth import get_current_user
from app.schemas.vendor import VendorCreate, VendorRead
from app.crud import vendors as crud_vendors
from app.schemas.user import UserRead

router = APIRouter(
    prefix="/vendors",
    tags=["vendors"],
    responses={
        401: {"description": "Unauthorized access"},
        403: {"description": "Forbidden"},
        404: {"description": "Vendor not found"},
    },
)


# =========================================================
# CREATE VENDOR
# =========================================================
@router.post(
    "/",
    response_model=VendorRead,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new vendor profile",
    description="""
    Create a new vendor profile in the marketplace.

    - Only users with the **vendor** role can create their vendor profile.
    - A user can have only one vendor profile linked to their account.
    """,
    response_description="The created vendor profile",
)
async def create_vendor(
    vendor_in: VendorCreate = Body(
        ...,
        description="Vendor details to create",
        example={
            "name": "Example Data Corp",
            "industry_focus": "Finance",
            "description": "Provider of high-quality financial datasets",
            "contact_email": "data@example.com",
        },
    ),
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    if current_user.role not in ("vendor", "admin"):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only vendors or admins can create vendor profiles.",
        )

    # ensure one vendor per user
    existing_vendors = await crud_vendors.list_vendors(db, limit=1000)
    if any(v.user_id == current_user.id for v in existing_vendors):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="This user already has a vendor profile.",
        )

    vendor_data = vendor_in.model_dump()
    vendor_data["user_id"] = str(current_user.id)

    vendor = await crud_vendors.create_vendor(db, vendor_data)
    return vendor


# =========================================================
# LIST VENDORS
# =========================================================
@router.get(
    "/",
    response_model=List[VendorRead],
    summary="List all vendors",
    description="Get a paginated list of all vendors in the marketplace. Accessible to all authenticated users.",
    response_description="List of vendor profiles",
)
async def list_vendors(
    limit: int = Query(100, description="Maximum number of vendors to return", ge=1, le=1000),
    offset: int = Query(0, description="Number of vendors to skip", ge=0),
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    vendors = await crud_vendors.list_vendors(db, limit=limit, offset=offset)
    return vendors


# =========================================================
# GET VENDOR BY ID
# =========================================================
@router.get(
    "/{vendor_id}",
    response_model=VendorRead,
    summary="Get vendor details by ID",
    description="Retrieve a vendor’s full profile using their UUID. Accessible to all authenticated users.",
    response_description="Vendor details",
)
async def get_vendor(
    vendor_id: str = Path(..., description="The UUID of the vendor to retrieve"),
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    vendor = await crud_vendors.get_vendor(db, vendor_id)
    if not vendor:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Vendor not found")
    return vendor


# =========================================================
# UPDATE VENDOR
# =========================================================
@router.put(
    "/{vendor_id}",
    response_model=VendorRead,
    summary="Update a vendor profile",
    description="""
    Update a vendor’s profile information.

    - **Admins** can update any vendor.
    - **Vendors** can only update their own profile.
    """,
    response_description="The updated vendor profile",
)
async def update_vendor(
    vendor_id: str = Path(..., description="The UUID of the vendor to update"),
    update: Dict = Body(
        ...,
        description="Fields to update (partial or full)",
        example={
            "description": "Updated description of the vendor",
            "contact_email": "new.email@vendor.com",
        },
    ),
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    vendor = await crud_vendors.get_vendor(db, vendor_id)
    if not vendor:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Vendor not found")

    # role-based check
    if current_user.role != "admin" and str(vendor.user_id) != str(current_user.id):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only update your own vendor profile.",
        )

    updated_vendor = await crud_vendors.update_vendor(db, vendor_id, update)
    return updated_vendor


# =========================================================
# DELETE VENDOR
# =========================================================
@router.delete(
    "/{vendor_id}",
    status_code=status.HTTP_200_OK,
    summary="Delete a vendor profile",
    description="""
    Delete a vendor and all associated resources.

    - **Admins** can delete any vendor.
    - **Vendors** can delete only their own profile.
    """,
    responses={
        200: {"description": "Vendor successfully deleted"},
        403: {"description": "Forbidden"},
        404: {"description": "Vendor not found"},
    },
)
async def delete_vendor(
    vendor_id: str = Path(..., description="The UUID of the vendor to delete"),
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    vendor = await crud_vendors.get_vendor(db, vendor_id)
    if not vendor:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Vendor not found")

    if current_user.role != "admin" and str(vendor.user_id) != str(current_user.id):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only delete your own vendor profile.",
        )

    ok = await crud_vendors.delete_vendor(db, vendor_id)
    if not ok:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Vendor not found")
    return {"deleted": True, "vendor_id": vendor_id}


buyers.py
from typing import List, Dict
from fastapi import APIRouter, Depends, HTTPException, status, Query, Path, Body
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.db import get_session
from app.core.auth import get_current_user
from app.schemas.user import UserRead
from app.schemas.buyer import BuyerCreate, BuyerRead
from app.crud import buyers as crud_buyers

router = APIRouter(
    prefix="/buyers",
    tags=["buyers"],
    responses={404: {"description": "Buyer not found"}},
)

# =========================================================
# CREATE BUYER (Buyer role only)
# =========================================================
@router.post(
    "/",
    response_model=BuyerRead,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new buyer profile",
    description="Only users with role='buyer' can create their buyer profile.",
)
async def create_buyer(
    buyer_in: BuyerCreate = Body(..., description="Buyer profile details"),
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    if current_user.role != "buyer":
        raise HTTPException(status_code=403, detail="Only buyers can create buyer profiles")

    # Prevent duplicate profile creation
    existing_buyers = await crud_buyers.list_buyers(db)
    if any(b.user_id == current_user.id for b in existing_buyers):
        raise HTTPException(status_code=400, detail="Buyer profile already exists for this user")

    buyer = await crud_buyers.create_buyer(db, buyer_in, user_id=current_user.id)
    return buyer


# =========================================================
# LIST BUYERS
# =========================================================
@router.get(
    "/",
    response_model=List[BuyerRead],
    summary="List all buyers",
    description="""
    Accessible to:
    - **Admin**: can view all buyers.
    - **Vendor**: can view all buyers.
    - **Buyer**: can view all buyers (for discovery).
    """,
)
async def get_buyers(
    limit: int = Query(100, description="Maximum number of buyers to return", ge=1, le=1000),
    offset: int = Query(0, description="Number of buyers to skip", ge=0),
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    if current_user.role not in ("admin", "vendor", "buyer"):
        raise HTTPException(status_code=403, detail="Access denied")

    buyers = await crud_buyers.list_buyers(db, limit=limit, offset=offset)
    return buyers


# =========================================================
# GET BUYER BY ID
# =========================================================
@router.get(
    "/{buyer_id}",
    response_model=BuyerRead,
    summary="Get buyer details by ID",
    description="Accessible to admins, vendors, or the buyer themselves.",
)
async def get_buyer(
    buyer_id: str = Path(..., description="The UUID of the buyer to retrieve"),
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    buyer = await crud_buyers.get_buyer(db, buyer_id)
    if not buyer:
        raise HTTPException(status_code=404, detail="Buyer not found")

    if current_user.role not in ("admin", "vendor", "buyer"):
        raise HTTPException(status_code=403, detail="Access denied")

    # Buyers can only view their own private profile
    if current_user.role == "buyer" and buyer.user_id != str(current_user.id):
        raise HTTPException(status_code=403, detail="You can only view your own profile")

    return buyer


# =========================================================
# UPDATE BUYER (Buyer or Admin)
# =========================================================
@router.put(
    "/{buyer_id}",
    response_model=BuyerRead,
    summary="Update buyer profile",
    description="Buyers can update their own profile. Admins can update any profile.",
)
async def update_buyer(
    buyer_id: str = Path(..., description="The UUID of the buyer to update"),
    update: Dict = Body(..., description="Fields to update"),
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    buyer = await crud_buyers.get_buyer(db, buyer_id)
    if not buyer:
        raise HTTPException(status_code=404, detail="Buyer not found")

    if current_user.role not in ("buyer", "admin"):
        raise HTTPException(status_code=403, detail="Only buyers or admins can update profiles")

    if current_user.role == "buyer" and buyer.user_id != str(current_user.id):
        raise HTTPException(status_code=403, detail="You can only update your own profile")

    updated_buyer = await crud_buyers.update_buyer(db, buyer_id, update)
    return updated_buyer


# =========================================================
# DELETE BUYER (Admin only)
# =========================================================
@router.delete(
    "/{buyer_id}",
    summary="Delete a buyer profile",
    description="Admin-only route for deleting buyer profiles.",
)
async def delete_buyer(
    buyer_id: str = Path(..., description="The UUID of the buyer to delete"),
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Only admins can delete buyers")

    ok = await crud_buyers.delete_buyer(db, buyer_id)
    if not ok:
        raise HTTPException(status_code=404, detail="Buyer not found")
    return {"deleted": True}


datasets.py
from typing import List, Dict, Any, Optional
import json

from fastapi import APIRouter, Depends, HTTPException, status, Query, Path, Body
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, text
from pydantic import BaseModel

from app.core.db import get_session
from app.core.auth import get_current_user
from app.schemas.dataset import DatasetCreate, DatasetRead
from app.schemas.user import UserRead
from app.crud import datasets as crud_datasets
from app.utils.embedding_utils import generate_embedding, build_embedding_input

router = APIRouter(prefix="/datasets", tags=["datasets"])


# =============================
# Dataset Update Model
# =============================
class DatasetUpdate(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    domain: Optional[str] = None
    dataset_type: Optional[str] = None
    granularity: Optional[str] = None
    pricing_model: Optional[str] = None
    license: Optional[str] = None
    topics: Optional[List[str]] = None
    entities: Optional[List[str]] = None
    temporal_coverage: Optional[Any] = None
    geographic_coverage: Optional[Any] = None
    visibility: Optional[str] = None
    status: Optional[str] = None
    columns: Optional[List[Dict[str, Any]]] = None


# =============================
# CREATE DATASET
# =============================
@router.post("/", response_model=DatasetRead, status_code=status.HTTP_201_CREATED)
async def create_dataset(
    dataset_in: DatasetCreate,
    current_user: UserRead = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    if current_user.role != "vendor":
        raise HTTPException(status_code=403, detail="Only vendors can create datasets")

    data = dataset_in.dict()
    data["owner_id"] = str(current_user.id)

    # Build embedding
    embedding_input = build_embedding_input(data)
    embedding_vector = await generate_embedding(embedding_input)
    data["embedding_input"] = embedding_input
    data["embedding"] = embedding_vector

    dataset = await crud_datasets.create_dataset(db, DatasetCreate(**data))
    return dataset


# =============================
# LIST DATASETS WITH FILTERING
# =============================
@router.get("/", response_model=List[DatasetRead])
async def list_datasets(
    filters: Optional[str] = Query(None, description="JSON string of dynamic filters"),
    search: Optional[str] = Query(None, description="Search in title or description"),
    limit: int = Query(50, ge=1, le=1000),
    offset: int = Query(0, ge=0),
    current_user: UserRead = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    """
    List datasets with optional search and dynamic filters.
    Buyers only see public datasets.
    """
    query = select(crud_datasets.Dataset)
    where_clauses = []

    # Role-based visibility
    if current_user.role == "buyer":
        where_clauses.append(crud_datasets.Dataset.visibility == "public")

    # Parse filters JSON
    filter_dict = {}
    if filters:
        try:
            filter_dict = json.loads(filters)
        except json.JSONDecodeError:
            raise HTTPException(status_code=400, detail="Invalid JSON for filters")

    for key, value in filter_dict.items():
        if not hasattr(crud_datasets.Dataset, key):
            continue
        attr = getattr(crud_datasets.Dataset, key)
        # Handle list fields
        if isinstance(value, list):
            where_clauses.append(attr.contains(value))
        else:
            where_clauses.append(attr == value)

    # Full-text search
    if search:
        where_clauses.append(
            or_(
                crud_datasets.Dataset.title.ilike(f"%{search}%"),
                crud_datasets.Dataset.description.ilike(f"%{search}%"),
            )
        )

    if where_clauses:
        query = query.where(and_(*where_clauses))

    query = query.limit(limit).offset(offset)
    result = await db.execute(query)
    datasets = result.scalars().all()
    return [DatasetRead.model_validate(ds) for ds in datasets]


# =============================
# GET SINGLE DATASET
# =============================
@router.get("/{dataset_id}", response_model=DatasetRead)
async def get_dataset(
    dataset_id: str = Path(...),
    current_user: UserRead = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    dataset = await crud_datasets.get_dataset(db, dataset_id)
    if not dataset:
        raise HTTPException(status_code=404, detail="Dataset not found")

    if current_user.role == "buyer" and dataset.visibility != "public":
        raise HTTPException(status_code=403, detail="Access denied")
    return dataset


# =============================
# UPDATE DATASET
# =============================
@router.put("/{dataset_id}", response_model=DatasetRead)
async def update_dataset(
    dataset_id: str,
    update: DatasetUpdate,
    current_user: UserRead = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    dataset = await crud_datasets.get_dataset(db, dataset_id)
    if not dataset:
        raise HTTPException(status_code=404, detail="Dataset not found")

    if current_user.role != "vendor" or str(dataset.owner_id) != str(current_user.id):
        raise HTTPException(status_code=403, detail="Not allowed to update this dataset")

    updated_dataset = await crud_datasets.update_dataset(db, dataset_id, update.dict(exclude_none=True))
    return updated_dataset


# =============================
# DELETE DATASET
# =============================
@router.delete("/{dataset_id}")
async def delete_dataset(
    dataset_id: str,
    current_user: UserRead = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    dataset = await crud_datasets.get_dataset(db, dataset_id)
    if not dataset:
        raise HTTPException(status_code=404, detail="Dataset not found")

    if current_user.role != "vendor" or str(dataset.owner_id) != str(current_user.id):
        raise HTTPException(status_code=403, detail="Not allowed to delete this dataset")

    ok = await crud_datasets.delete_dataset(db, dataset_id)
    if not ok:
        raise HTTPException(status_code=404, detail="Dataset not found")
    return {"deleted": True}


# =============================
# SEARCH DATASETS BY EMBEDDING
# =============================
class DatasetSearchQuery(BaseModel):
    query: str
    top_k: int = Query(5, ge=1, le=100)


class DatasetSearchResult(BaseModel):
    results: List[Dict[str, Any]]


@router.post("/search/embedding", response_model=DatasetSearchResult)
async def search_by_embedding(
    query: DatasetSearchQuery = Body(...),
    current_user: UserRead = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    emb = await generate_embedding(query.query)

    # Wrap raw SQL string with text()
    result = await db.execute(
        text("SELECT id, title, description, embedding, visibility FROM datasets WHERE embedding IS NOT NULL")
    )
    rows = result.fetchall()

    import numpy as np

    def cosine(a, b):
        a = np.array(a, dtype=float)
        b = np.array(b, dtype=float)
        if np.linalg.norm(a) == 0 or np.linalg.norm(b) == 0:
            return 0.0
        return float(np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b)))

    scored = []
    for r in rows:
        emb_db = r[3]
        vis = r[4]

        if current_user.role == "buyer" and vis != "public":
            continue

        if emb_db is None:
            continue
        emb_db_list = list(emb_db) if not isinstance(emb_db, list) else emb_db
        score = cosine(emb, emb_db_list)
        scored.append({"id": r[0], "title": r[1], "description": r[2], "score": score})

    scored.sort(key=lambda x: x["score"], reverse=True)
    return {"results": scored[: query.top_k]}

dataset_columns.py
from typing import List
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID

from app.core.db import get_session
from app.schemas.dataset_column import DatasetColumnCreate, DatasetColumnRead
from app.crud import dataset_columns as crud_cols
from app.core.auth import get_current_user
from app.schemas.user import UserRead
from app.models.models import Dataset

router = APIRouter(prefix="/dataset-columns", tags=["dataset-columns"])


# --------------------------
# Helper: verify vendor ownership
# --------------------------
async def verify_vendor_owns_dataset(
    dataset_id: UUID, current_user: UserRead, db: AsyncSession
):
    """Check if current user is allowed to modify this dataset."""
    if current_user.role == "admin":
        return True

    if current_user.role != "vendor":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You do not have permission to perform this action.",
        )

    dataset = await db.get(Dataset, str(dataset_id))
    if not dataset:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Dataset not found.",
        )
    if dataset.vendor_id != current_user.vendor_profile.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You do not own this dataset.",
        )
    return True


# --------------------------
# CREATE COLUMN
# --------------------------
@router.post("/", response_model=DatasetColumnRead, status_code=status.HTTP_201_CREATED)
async def create_column(
    col_in: DatasetColumnCreate,
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    await verify_vendor_owns_dataset(col_in.dataset_id, current_user, db)
    col = await crud_cols.create_dataset_column(db, col_in)
    return col


# --------------------------
# LIST COLUMNS FOR A DATASET
# --------------------------
@router.get("/dataset/{dataset_id}", response_model=List[DatasetColumnRead])
async def get_columns(
    dataset_id: UUID,
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    # Admins or vendors of this dataset can list; buyers can only view public datasets
    dataset = await db.get(Dataset, str(dataset_id))
    if not dataset:
        raise HTTPException(status_code=404, detail="Dataset not found")

    if current_user.role == "vendor" and dataset.vendor_id != current_user.vendor_profile.id:
        raise HTTPException(status_code=403, detail="Not authorized for this dataset")

    # Buyers can see only public datasets
    if current_user.role == "buyer" and dataset.visibility != "public":
        raise HTTPException(status_code=403, detail="Not authorized for this dataset")

    cols = await crud_cols.list_dataset_columns(db, str(dataset_id))
    return cols


# --------------------------
# GET SINGLE COLUMN
# --------------------------
@router.get("/{col_id}", response_model=DatasetColumnRead)
async def get_column(
    col_id: int,
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    col = await crud_cols.get_dataset_column(db, col_id)
    if not col:
        raise HTTPException(status_code=404, detail="Column not found")

    # Ownership/visibility check
    dataset = await db.get(Dataset, col.dataset_id)
    if current_user.role == "vendor" and dataset.vendor_id != current_user.vendor_profile.id:
        raise HTTPException(status_code=403, detail="Not authorized for this dataset")
    if current_user.role == "buyer" and dataset.visibility != "public":
        raise HTTPException(status_code=403, detail="Not authorized for this dataset")

    return col


# --------------------------
# UPDATE COLUMN
# --------------------------
@router.put("/{col_id}", response_model=DatasetColumnRead)
async def update_column(
    col_id: int,
    update: dict,
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    col = await crud_cols.get_dataset_column(db, col_id)
    if not col:
        raise HTTPException(status_code=404, detail="Column not found")

    await verify_vendor_owns_dataset(col.dataset_id, current_user, db)
    updated_col = await crud_cols.update_dataset_column(db, col_id, update)
    return updated_col


# --------------------------
# DELETE COLUMN
# --------------------------
@router.delete("/{col_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_column(
    col_id: int,
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    col = await crud_cols.get_dataset_column(db, col_id)
    if not col:
        raise HTTPException(status_code=404, detail="Column not found")

    await verify_vendor_owns_dataset(col.dataset_id, current_user, db)
    await crud_cols.delete_dataset_column(db, col_id)
    return None  # 204 No Content


agents.py
from typing import List, Optional, Dict
from fastapi import APIRouter, Depends, HTTPException, status, Query, Path, Body
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.db import get_session
from app.core.auth import get_current_user
from app.schemas.agent import AgentCreate, AgentRead
from app.crud import agents as crud_agents
from app.schemas.user import UserRead

router = APIRouter(
    prefix="/agents",
    tags=["agents"],
    responses={404: {"description": "Agent not found"}},
)

# =========================================================
# CREATE NEW AI AGENT (Admin or Vendor)
# =========================================================
@router.post(
    "/",
    response_model=AgentRead,
    status_code=status.HTTP_201_CREATED,
    summary="Create a new AI agent",
)
async def create_agent(
    agent_in: AgentCreate = Body(...),
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    """Create a new AI agent (Admin or Vendor only)."""
    if current_user.role not in {"admin", "vendor"}:
        raise HTTPException(status_code=403, detail="Only admins or vendors can create agents")

    # Vendors can only create agents under their own vendor_id
    if current_user.role == "vendor" and str(agent_in.vendor_id) != str(current_user.id):
        raise HTTPException(status_code=403, detail="Vendors can only create agents for their own account")

    agent = await crud_agents.create_agent(db, agent_in)
    return agent


# =========================================================
# LIST AGENTS
# =========================================================
@router.get(
    "/",
    response_model=List[AgentRead],
    summary="List AI agents",
)
async def list_agents(
    vendor_id: Optional[str] = Query(None, description="Filter by vendor ID"),
    active: Optional[bool] = Query(None, description="Filter by active status"),
    limit: int = Query(100, description="Max number of agents", ge=1, le=1000),
    offset: int = Query(0, description="Number of agents to skip", ge=0),
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    """
    - Admin: list all agents.
    - Vendor: list only own agents.
    - Buyer: read-only list view of all agents (marketplace discovery).
    """
    if current_user.role == "vendor":
        vendor_id = str(current_user.id)

    agents = await crud_agents.list_agents(db, vendor_id=vendor_id, active=active, limit=limit, offset=offset)
    return agents


# =========================================================
# GET A SPECIFIC AGENT
# =========================================================
@router.get(
    "/{agent_id}",
    response_model=AgentRead,
    summary="Get a specific AI agent",
)
async def get_agent(
    agent_id: str = Path(..., description="The UUID of the agent"),
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    agent = await crud_agents.get_agent(db, agent_id)
    if not agent:
        raise HTTPException(status_code=404, detail="Agent not found")

    # Vendors can only view their own agents
    if current_user.role == "vendor" and str(agent.vendor_id) != str(current_user.id):
        raise HTTPException(status_code=403, detail="Not authorized to view this agent")

    return agent


# =========================================================
# UPDATE AN AGENT
# =========================================================
@router.put(
    "/{agent_id}",
    response_model=AgentRead,
    summary="Update an AI agent",
)
async def update_agent(
    agent_id: str,
    update_data: Dict = Body(...),
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    """Update an AI agent's configuration (Admin or owning Vendor)."""
    agent = await crud_agents.get_agent(db, agent_id)
    if not agent:
        raise HTTPException(status_code=404, detail="Agent not found")

    if current_user.role not in {"admin", "vendor"}:
        raise HTTPException(status_code=403, detail="Only admins or vendors can update agents")

    if current_user.role == "vendor" and str(agent.vendor_id) != str(current_user.id):
        raise HTTPException(status_code=403, detail="Vendors can only update their own agents")

    updated_agent = await crud_agents.update_agent(db, agent_id, update_data)
    return updated_agent


# =========================================================
# DELETE AN AGENT
# =========================================================
@router.delete(
    "/{agent_id}",
    summary="Delete an AI agent",
)
async def delete_agent(
    agent_id: str,
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    """Delete an AI agent (Admin or owning Vendor)."""
    agent = await crud_agents.get_agent(db, agent_id)
    if not agent:
        raise HTTPException(status_code=404, detail="Agent not found")

    if current_user.role not in {"admin", "vendor"}:
        raise HTTPException(status_code=403, detail="Only admins or vendors can delete agents")

    if current_user.role == "vendor" and str(agent.vendor_id) != str(current_user.id):
        raise HTTPException(status_code=403, detail="Vendors can only delete their own agents")

    await crud_agents.delete_agent(db, agent_id)
    return {"deleted": True}

chats.py
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID

from app.core.db import get_session
from app.core.auth import get_current_user
from app.crud import chats as crud_chats
from app.schemas.chat import ChatCreate, ChatRead
from app.schemas.user import UserRead
from app.models.models import Chat, Vendor

router = APIRouter(prefix="/chats", tags=["chats"])


# =============================
# HELPER: VERIFY USER ACCESS
# =============================
async def verify_chat_access(chat: Chat, current_user: UserRead):
    """
    Check if current user can access this chat.
    - Admin: full access
    - Vendor: can access only their vendor_id chats
    - Buyer/User: can access only their user_id chats
    """
    if current_user.role == "admin":
        return True

    if current_user.role == "vendor":
        if chat.vendor_id != getattr(current_user.vendor_profile, "id", None):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Not authorized to access this chat.",
            )
        return True

    # Buyers or general users
    if chat.user_id != current_user.id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to access this chat.",
        )

    return True


# =============================
# CREATE CHAT
# =============================
@router.post("/", response_model=ChatRead, status_code=status.HTTP_201_CREATED)
async def create_chat(
    chat_in: ChatCreate,
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    """
    Create a new chat.
    RBAC:
    - Users can create their own chats
    - Vendors can create chats under their vendor_id
    """
    # Enforce ownership: user_id must match current_user.id unless admin
    if current_user.role != "admin" and str(chat_in.user_id) != str(current_user.id):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Cannot create chat for another user.",
        )

    # Vendors cannot create chats for other vendors
    if current_user.role == "vendor" and chat_in.vendor_id:
        if str(chat_in.vendor_id) != str(current_user.vendor_profile.id):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Cannot create chat for another vendor.",
            )

    chat = await crud_chats.create_chat(db, chat_in)
    return chat


# =============================
# GET CHAT BY ID
# =============================
@router.get("/{chat_id}", response_model=ChatRead)
async def get_chat(
    chat_id: UUID,
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    chat = await crud_chats.get_chat(db, str(chat_id))
    if not chat:
        raise HTTPException(status_code=404, detail="Chat not found")

    await verify_chat_access(chat.model_copy(), current_user)
    return chat


# =============================
# LIST CHATS
# =============================
@router.get("/", response_model=List[ChatRead])
async def list_chats(
    user_id: Optional[UUID] = None,
    vendor_id: Optional[UUID] = None,
    agent_id: Optional[UUID] = None,
    chat_type: Optional[str] = None,
    limit: int = 100,
    offset: int = 0,
    include_inactive: bool = False,
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    """
    List chats with optional filters.
    RBAC:
    - Admin: can list all
    - Vendor: can list only their vendor_id chats
    - User/Buyer: can list only their own user_id chats
    """
    # Enforce RBAC filters automatically
    if current_user.role == "vendor":
        vendor_id = getattr(current_user.vendor_profile, "id", None)
    elif current_user.role != "admin":
        user_id = current_user.id

    chats = await crud_chats.list_chats(
        db=db,
        user_id=str(user_id) if user_id else None,
        vendor_id=str(vendor_id) if vendor_id else None,
        agent_id=str(agent_id) if agent_id else None,
        chat_type=chat_type,
        limit=limit,
        offset=offset,
        include_inactive=include_inactive,
    )
    return chats


# =============================
# UPDATE CHAT
# =============================
@router.put("/{chat_id}", response_model=ChatRead)
async def update_chat(
    chat_id: UUID,
    update_data: dict,
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    chat_obj = await crud_chats.get_chat(db, str(chat_id))
    if not chat_obj:
        raise HTTPException(status_code=404, detail="Chat not found")

    await verify_chat_access(chat_obj.model_copy(), current_user)

    updated_chat = await crud_chats.update_chat(db, str(chat_id), update_data)
    return updated_chat


# =============================
# DELETE CHAT
# =============================
@router.delete("/{chat_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_chat(
    chat_id: UUID,
    db: AsyncSession = Depends(get_session),
    current_user: UserRead = Depends(get_current_user),
):
    chat_obj = await crud_chats.get_chat(db, str(chat_id))
    if not chat_obj:
        raise HTTPException(status_code=404, detail="Chat not found")

    await verify_chat_access(chat_obj.model_copy(), current_user)

    success = await crud_chats.delete_chat(db, str(chat_id))
    if not success:
        raise HTTPException(status_code=400, detail="Failed to delete chat")

    return None

chat_messages.py
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID

from app.core.db import get_session
from app.core.auth import get_current_user
from app.crud import chat_messages as chat_crud
from app.schemas.chat_message import ChatMessageCreate, ChatMessageRead
from app.schemas.user import UserRead
from app.models.models import Chat

router = APIRouter(prefix="/chat-messages", tags=["chat-messages"])


# =========================================================
# CREATE NEW CHAT MESSAGE
# =========================================================
@router.post("/", response_model=ChatMessageRead, status_code=status.HTTP_201_CREATED)
async def create_message(
    message_in: ChatMessageCreate,
    current_user: UserRead = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    """
    Create a new chat message. The current user is the sender.
    """
    chat_obj = await db.get(Chat, str(message_in.chat_id))
    if not chat_obj or (chat_obj.user_id != current_user.id and chat_obj.vendor_id != current_user.id):
        raise HTTPException(status_code=403, detail="You do not have access to this chat")

    return await chat_crud.create_chat_message(db, message_in)


# =========================================================
# GET CHAT MESSAGE BY ID
# =========================================================
@router.get("/{message_id}", response_model=ChatMessageRead)
async def get_message(
    message_id: int,
    current_user: UserRead = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    """
    Retrieve a single chat message by its ID.
    Only participants of the chat can access it.
    """
    message = await chat_crud.get_chat_message(db, message_id)
    if not message:
        raise HTTPException(status_code=404, detail="Chat message not found")

    chat_obj = await db.get(Chat, message.chat_id)
    if not chat_obj or (chat_obj.user_id != current_user.id and chat_obj.vendor_id != current_user.id):
        raise HTTPException(status_code=403, detail="You do not have access to this chat")

    return message


# =========================================================
# LIST MESSAGES (OPTIONAL FILTERING, SORTED LATEST FIRST)
# =========================================================
@router.get("/", response_model=List[ChatMessageRead])
async def list_messages(
    chat_id: Optional[UUID] = Query(None, description="Filter messages by chat ID"),
    sender_type: Optional[str] = Query(None, description="Filter messages by sender type"),
    limit: int = Query(100, ge=1, le=500, description="Number of messages to return"),
    offset: int = Query(0, ge=0, description="Pagination offset"),
    include_metadata: bool = Query(True, description="Include message_metadata field"),
    current_user: UserRead = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    """
    List chat messages with optional filtering by chat_id or sender_type.
    - Sorted by created_at descending (latest first)
    - RBAC enforced: user must be participant in chat.
    """
    if chat_id:
        chat_obj = await db.get(Chat, str(chat_id))
        if not chat_obj or (chat_obj.user_id != current_user.id and chat_obj.vendor_id != current_user.id):
            raise HTTPException(status_code=403, detail="You do not have access to this chat")

    messages = await chat_crud.list_chat_messages(
        db,
        chat_id=str(chat_id) if chat_id else None,
        sender_type=sender_type,
        limit=limit,
        offset=offset,
    )

    if not include_metadata:
        # Strip metadata from response for lightweight payload
        for msg in messages:
            msg.message_metadata = None

    # Sort messages by created_at descending
    messages.sort(key=lambda x: x.created_at or 0, reverse=True)
    return messages


# =========================================================
# LIST MESSAGES BY CHAT
# =========================================================
@router.get("/by-chat/{chat_id}", response_model=List[ChatMessageRead])
async def list_messages_by_chat(
    chat_id: UUID,
    limit: int = Query(50, ge=1, le=200, description="Number of messages to return"),
    offset: int = Query(0, ge=0, description="Pagination offset"),
    include_metadata: bool = Query(True, description="Include message_metadata field"),
    current_user: UserRead = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    """
    List all messages for a specific chat, sorted by creation time (latest first).
    - RBAC enforced: only participants of the chat can view.
    - Supports pagination via limit and offset.
    """
    chat_obj = await db.get(Chat, str(chat_id))
    if not chat_obj:
        raise HTTPException(status_code=404, detail="Chat not found")
    if chat_obj.user_id != current_user.id and chat_obj.vendor_id != current_user.id:
        raise HTTPException(status_code=403, detail="You do not have access to this chat")

    messages = await chat_crud.list_chat_messages(
        db, chat_id=str(chat_id), limit=limit, offset=offset
    )

    if not include_metadata:
        for msg in messages:
            msg.message_metadata = None

    messages.sort(key=lambda x: x.created_at or 0, reverse=True)
    return messages


# =========================================================
# UPDATE CHAT MESSAGE
# =========================================================
@router.patch("/{message_id}", response_model=ChatMessageRead)
async def update_message(
    message_id: int,
    update_data: dict,
    current_user: UserRead = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    """
    Update a chat message. Only 'message' and 'message_metadata' are updatable.
    Only the sender of the message can update it.
    """
    message = await chat_crud.get_chat_message(db, message_id)
    if not message:
        raise HTTPException(status_code=404, detail="Chat message not found")

    if message.sender_type == "user" and str(message.chat.user_id) != current_user.id:
        raise HTTPException(status_code=403, detail="You do not have permission to edit this message")

    updated_message = await chat_crud.update_chat_message(db, message_id, update_data)
    return updated_message


# =========================================================
# DELETE CHAT MESSAGE
# =========================================================
@router.delete("/{message_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_message(
    message_id: int,
    current_user: UserRead = Depends(get_current_user),
    db: AsyncSession = Depends(get_session),
):
    """
    Permanently delete a chat message by ID.
    Only the sender or an admin can delete messages.
    """
    message = await chat_crud.get_chat_message(db, message_id)
    if not message:
        raise HTTPException(status_code=404, detail="Chat message not found")

    if message.sender_type == "user" and str(message.chat.user_id) != current_user.id and current_user.role != "admin":
        raise HTTPException(status_code=403, detail="You do not have permission to delete this message")

    deleted = await chat_crud.delete_chat_message(db, message_id)
    if not deleted:
        raise HTTPException(status_code=500, detail="Failed to delete message")
    return
